// @(h)DebugStationTraceListener.cs ver 0.00 ( '22.03.25 Nov-Lab ) 作成開始
// @(h)DebugStationTraceListener.cs ver 0.51 ( '22.04.22 Nov-Lab ) ベータ版完成
// @(h)DebugStationTraceListener.cs ver 0.52 ( '22.05.01 Nov-Lab ) 機能修正：RecursionBlocker を使って自己再帰呼び出しを防止するようにした。
// @(h)DebugStationTraceListener.cs ver 1.03 ( '22.05.05 Nov-Lab ) 初版完成
// @(h)DebugStationTraceListener.cs ver 1.04 ( '22.05.10 Nov-Lab ) 機能追加：カテゴリ名に対応した。
// @(h)DebugStationTraceListener.cs ver 1.04a( '22.05.24 Nov-Lab ) その他  ：コメント整理

// @(s)
// 　【デバッグステーショントレースリスナー】トレース出力やデバッグ出力をデバッグステーションアプリケーションに転送するトレースリスナー機能を提供します。

using System;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Collections.Generic;

using NovLab.DebugStation.DebugUseBlocker;  // Debug/Traceクラス使用ブロッカー(DebugStationTraceListener では、Debug クラスと Trace クラスは使用禁止)


namespace NovLab.DebugStation
{
    //====================================================================================================
    /// <summary>
    /// 【デバッグステーショントレースリスナー】
    /// トレース出力やデバッグ出力をデバッグステーションアプリケーションに転送するトレースリスナー機能を提供します。
    /// </summary>
    /// <remarks>
    /// 簡単な使い方<br></br>
    /// ・DebugStationTraceListener.RegisterListener(); を呼び出すと、Debug クラスと Trace クラスの出力が
    ///   デバッグステーションへ送られるようになります。<br></br>
    /// <br></br>
    /// 補足<br></br>
    /// ・TraceOutputOptions プロパティーは使用しません。常にすべてのオプション コンテンツを送信します。<br></br>
    /// <br></br>
    /// 関連クラスの使い分け方<br></br>
    /// ・<see cref="NLDebug"/> クラスを使うと、任意の情報メッセージやイベントをデバッグステーションへ送ることができます。<br></br>
    /// ・<see cref="DebugStationTraceListener"/> クラスを使うと、Debug クラスや Trace クラスの出力をデバッグステーションへ送ることができます。<br></br>
    /// ・<see cref="DebugStationClient"/> クラスを直接使うと、複数のデバッグステーションを使い分けることができます。<br></br>
    /// <br></br>
    /// Tips<br></br>
    /// ・出力先は既定のデバッグステーションアプリケーションです。
    ///   宛先を変更したい場合は、あらかじめ <see cref="DebugStationClient.OpenDefault(string)"/> を、
    ///   メールスロット名を指定して呼び出しておきます。<br></br>
    /// </remarks>
    //====================================================================================================
    public class DebugStationTraceListener : TraceListener
    {
        //====================================================================================================
        // 内部定数
        //====================================================================================================
        /// <summary>
        /// 【既定のトレースリスナー名】
        /// </summary>
        private const string LISTENER_NAME = "DebugStation";


        //====================================================================================================
        // 内部フィールド
        //====================================================================================================
        /// <summary>
        /// 【呼び出し回数カウンタ】自己再帰呼び出しの防止に使用します。
        /// </summary>
        protected Referrable<int> m_callCounter = new Referrable<int>();

        /// <summary>
        /// 【未完メッセージバッファ】Write() メソッドで書き込まれた未完メッセージ文字列を蓄積します。
        /// </summary>
        /// <remarks>
        /// 補足
        /// <code>
        /// 呼び出し手順          ：未完メッセージバッファの扱い方
        /// ----------------------：------------------------------------------------------------------------------------------
        /// Write -> Write        ：カテゴリ名が同じ場合は追加する。カテゴリ名が異なる場合は既存分を送信し、新規分を蓄積する。
        /// Write -> WriteLine    ：カテゴリ名が同じ場合は連結して送信し、異なる場合は別々に送信する。
        /// Write -> WriteLine以外：連結せずに別々に送信する。
        /// </code>
        /// </remarks>
        protected string m_messageBuffer;

        /// <summary>
        /// 【カテゴリ名バッファ】Write() メソッドで書き込まれた未完メッセージ文字列に対応するカテゴリ名を保持します。[null = カテゴリなし]
        /// </summary>
        protected string m_categoryBuffer;


        //====================================================================================================
        // コンストラクター
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【既定のコンストラクター】既定の内容で新しいインスタンスを初期化します。
        /// Name プロパティ値は "DebugStation" になります。
        /// </summary>
        //--------------------------------------------------------------------------------
        public DebugStationTraceListener()
        {
            //------------------------------------------------------------
            /// 既定の内容で新しいインスタンスを初期化する
            //------------------------------------------------------------
            Name = LISTENER_NAME;                                       //// トレースリスナー名 = 既定の名前
        }


        //====================================================================================================
        // 内部メソッド
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【デバッグステーションクライアント取得】デバッグステーションクライアントを取得します。未オープンの場合は、既定の宛先でオープンします。
        /// </summary>
        /// <returns>
        /// デバッグステーションクライアント
        /// </returns>
        //--------------------------------------------------------------------------------
        private static DebugStationClient M_GetOrOpenClient() => DebugStationClient.GetOrOpenDefault();


        //====================================================================================================
        // リスナー操作
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【リスナー登録済みチェック】
        /// DebugStationTraceListener がリスナーに登録されているかどうかをチェックします。
        /// </summary>
        /// <returns>
        /// 登録済み状態[true = 登録済み / false = 未登録]
        /// </returns>
        //--------------------------------------------------------------------------------
        public static bool ExistsInListener()
        {
            //------------------------------------------------------------
            /// DebugStationTraceListener がリスナーに登録されているかどうかをチェックする
            //------------------------------------------------------------
            foreach (var listener in System.Diagnostics.Debug.Listeners)
            {                                                                   //// リスナーコレクションを繰り返す
                if (listener is DebugStationTraceListener)
                {                                                               /////  DebugStationTraceListener型の場合
                    return true;                                                //////   戻り値 = true(登録済み) で関数終了
                }
            }

            return false;                                               //// 登録されていなかった場合、戻り値 = false(未登録) で関数終了
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【リスナー登録】DebugStationTraceListener をリスナーに登録します。すでに登録されている場合は何もしません。
        /// </summary>
        //--------------------------------------------------------------------------------
        public static void RegisterListener()
        {
            //------------------------------------------------------------
            /// DebugStationTraceListener をリスナーに登録する
            //------------------------------------------------------------
            if (ExistsInListener() == false)
            {                                                           //// DebugStationTraceListener がリスナーに登録されていない場合
                System.Diagnostics.Debug.Listeners.Add(
                    new DebugStationTraceListener());                   /////  DebugStationTraceListener を生成し、リスナーに登録する
            }
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【リスナー登録解除】すべての DebugStationTraceListener をリスナーから登録解除します。
        /// </summary>
        //--------------------------------------------------------------------------------
        public static void UnregisterListener()
        {
            //------------------------------------------------------------
            /// 対象リスナーを収集する
            //------------------------------------------------------------
            var targetListeners = new Collection<TraceListener>();      //// 対象リスナーコレクションを生成する

            foreach (TraceListener listener in System.Diagnostics.Debug.Listeners)
            {                                                           //// デバッグリスナーコレクションを繰り返す
                if (listener is DebugStationTraceListener)
                {                                                       /////  DebugStationTraceListener型の場合
                    targetListeners.Add(listener);                      //////   対象リスナーコレクションに追加する
                }
            }

            //------------------------------------------------------------
            /// 対象リスナーを登録解除する
            //------------------------------------------------------------
            foreach (var listener in targetListeners)
            {                                                           //// 対象リスナーコレクションを繰り返す
                System.Diagnostics.Debug.Listeners.Remove(listener);    /////  リスナーから登録解除する
            }
        }


        //====================================================================================================
        // 内部メソッド
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【デバッグデータ送信】デバッグデータをデバッグステーションへ送信します。
        /// </summary>
        /// <param name="debugData">[in ]：デバッグデータ</param>
        //--------------------------------------------------------------------------------
        protected void M_Send(DebugData debugData)
        {
            // ＜メモ＞
            // ・このメソッドの呼び出し先が Debug.Print などを使用した場合、自己再帰呼び出しが発生してスタックオーバーフローを起こします。
            //   RecursionBlocker によってそれを防止しています。
            //------------------------------------------------------------
            /// デバッグデータをデバッグステーションへ送信する
            //------------------------------------------------------------
            using (var recursionBlocker = new RecursionBlocker(m_callCounter))
            {                                                           //// using：自己再帰呼び出しブロックを開始する
                if (m_callCounter.Value <= 1)
                {                                                       /////  呼び出し回数カウンタ <= 1 の場合(自己再帰呼び出しでない場合)
                    debugData.SendTo(M_GetOrOpenClient());              //////   デバッグデータをデバッグステーションへ送信する
                }
            }
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【メッセージ文字列送信】デバッグステーションにメッセージ文字列を送信します。未完メッセージバッファは参照も操作もしません。
        /// </summary>
        /// <param name="message"> [in ]：メッセージ文字列</param>
        /// <param name="category">[in ]：カテゴリ名[null = カテゴリなし]</param>
        //--------------------------------------------------------------------------------
        protected void M_SendMessage(string message, string category)
        {
            //------------------------------------------------------------
            /// デバッグステーションにメッセージ文字列を送信する
            //------------------------------------------------------------
            var debugData = DebugData.CreateForMessageInfo(
                IndentLevel, message, category);                        //// メッセージ情報用にデバッグデータを生成する
            M_Send(debugData);                                          //// デバッグデータ送信処理を行う
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【未完メッセージバッファ連結可能チェック】
        /// 未完メッセージバッファの内容を連結できるかどうかチェックします。
        /// </summary>
        /// <param name="category">[in ]：カテゴリ名[null = カテゴリなし]</param>
        /// <returns>
        /// チェック結果[true = 連結可能 / false = 連結不能]
        /// </returns>
        /// <remarks>
        /// 補足<br></br>
        /// ・カテゴリ名は null(カテゴリなし) と空文字列を区別します。<br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        protected bool M_CanJoinBuffer(string category)
        {
            //------------------------------------------------------------
            /// 未完メッセージバッファの内容を連結できるかどうかチェックする
            //------------------------------------------------------------
            if (string.IsNullOrEmpty(m_messageBuffer))
            {                                                           //// 未完メッセージバッファが空っぽの場合
                return true;                                            /////  戻り値 = true(連結可能) で関数終了
            }

            if (category == m_categoryBuffer)
            {                                                           //// カテゴリ名がバッファ側と同じ場合(連結すべき場合)
                return true;                                            /////  戻り値 = true(連結可能) で関数終了
            }
            else
            {                                                           //// カテゴリ名がバッファ側と異なる場合(連結できない場合)
                return false;                                           /////  戻り値 = false(連結不能) で関数終了
            }
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【未完メッセージバッファフラッシュ】
        /// 未完メッセージバッファに未送信のメッセージがある場合は、その内容を送信してバッファをクリアします。
        /// </summary>
        //--------------------------------------------------------------------------------
        protected void M_FlushBuffer()
        {
            //------------------------------------------------------------
            /// 未完メッセージバッファをフラッシュする
            //------------------------------------------------------------
            if (string.IsNullOrEmpty(m_messageBuffer))
            {                                                           //// 未完メッセージバッファが空っぽの場合
                return;                                                 /////  何もせずに関数終了
            }

            M_SendMessage(m_messageBuffer, m_categoryBuffer);           //// メッセージ文字列送信処理を行う
            m_messageBuffer = null;                                     //// 未完メッセージバッファ = null にクリアする
            m_categoryBuffer = null;                                    //// カテゴリ名バッファ = null にクリアする
        }


        //====================================================================================================
        // TraceListener メソッドのオーバーライド(文字列形式出力系)
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【文字列形式出力(未完)】デバッグステーションに未完メッセージを書き込みます。
        /// </summary>
        /// <param name="message">[in ]：メッセージ</param>
        /// <remarks>
        /// 補足<br></br>
        /// ・実際には即座に書き込まずにバッファに蓄積し、後で WriteLine や TraceEvent などが
        ///   呼び出されたタイミングで一緒に書き込みます。<br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void Write(string message)
        {
            //------------------------------------------------------------
            /// デバッグステーションに未完メッセージを書き込む
            //------------------------------------------------------------
            if (M_CanJoinBuffer(null) == false)
            {                                                           //// 未完メッセージバッファと連結可能でない場合
                M_FlushBuffer();                                        /////  未完メッセージバッファフラッシュ処理を行う
            }

            m_messageBuffer += message;                                 //// メッセージを未完メッセージバッファに追加する
            m_categoryBuffer = null;                                    //// カテゴリ名(null)をバッファに設定する
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【文字列形式出力(未完)】デバッグステーションに未完メッセージを書き込みます。
        /// </summary>
        /// <param name="message"> [in ]：メッセージ</param>
        /// <param name="category">[in ]：カテゴリ名</param>
        /// <remarks>
        /// 補足<br></br>
        /// ・実際には即座に書き込まずにバッファに蓄積し、後で WriteLine や TraceEvent などが
        ///   呼び出されたタイミングで一緒に書き込みます。<br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void Write(string message, string category)
        {
            //------------------------------------------------------------
            /// デバッグステーションに未完メッセージを書き込む
            //------------------------------------------------------------
            if (M_CanJoinBuffer(category) == false)
            {                                                           //// 未完メッセージバッファと連結可能でない場合
                M_FlushBuffer();                                        /////  未完メッセージバッファフラッシュ処理を行う
            }

            m_messageBuffer += message;                                 //// メッセージを未完メッセージバッファに追加する
            m_categoryBuffer = category;                                //// カテゴリ名をバッファに設定する
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【文字列形式出力(終端)】デバッグステーションにメッセージと行終端記号を書き込みます。
        /// </summary>
        /// <param name="message">[in ]：メッセージ</param>
        /// <remarks>
        /// 補足<br></br>
        /// ・実際には行終端記号は書き込まずに、蓄積されている未完メッセージを連結して一緒に送信します。<br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void WriteLine(string message)
        {
            //------------------------------------------------------------
            /// 未完メッセージバッファの前処理をする
            //------------------------------------------------------------
            if (M_CanJoinBuffer(null))
            {                                                           //// 未完メッセージバッファと連結可能な場合
                message = m_messageBuffer + message;                    /////  メッセージ文字列の前に未完メッセージバッファの内容を追加する
                m_messageBuffer = null;                                 /////  未完メッセージバッファ = null にクリアする
                m_categoryBuffer = null;                                /////  カテゴリ名バッファ = null にクリアする
            }
            else
            {                                                           //// 未完メッセージバッファと連結可能でない場合
                M_FlushBuffer();                                        /////  未完メッセージバッファフラッシュ処理を行う
            }

            //------------------------------------------------------------
            /// デバッグステーションにメッセージと行終端記号を書き込む
            //------------------------------------------------------------
            var debugData = DebugData.CreateForMessageInfo(
                IndentLevel, message, null);                            //// メッセージ情報用にデバッグデータを生成する
            M_Send(debugData);                                          //// デバッグデータ送信処理を行う
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【文字列形式出力(終端)】デバッグステーションにメッセージと行終端記号を書き込みます。
        /// </summary>
        /// <param name="message"> [in ]：メッセージ</param>
        /// <param name="category">[in ]：カテゴリ名</param>
        /// <remarks>
        /// 補足<br></br>
        /// ・実際には行終端記号は書き込まずに、蓄積されている未完メッセージを連結して一緒に送信します。<br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void WriteLine(string message, string category)
        {
            //------------------------------------------------------------
            /// 未完メッセージバッファの前処理をする
            //------------------------------------------------------------
            if (M_CanJoinBuffer(category))
            {                                                           //// 未完メッセージバッファと連結可能な場合
                message = m_messageBuffer + message;                    /////  メッセージ文字列の前に未完メッセージバッファの内容を追加する
                m_messageBuffer = null;                                 /////  未完メッセージバッファ = null にクリアする
                m_categoryBuffer = null;                                /////  カテゴリ名バッファ = null にクリアする
            }
            else
            {                                                           //// 未完メッセージバッファと連結可能でない場合
                M_FlushBuffer();                                        /////  未完メッセージバッファフラッシュ処理を行う
            }

            //------------------------------------------------------------
            /// デバッグステーションにメッセージと行終端記号を書き込む
            //------------------------------------------------------------
            var debugData = DebugData.CreateForMessageInfo(
                IndentLevel, message, category);                        //// メッセージ情報用にデバッグデータを生成する
            M_Send(debugData);                                          //// デバッグデータ送信処理を行う
        }


        //====================================================================================================
        // TraceListener メソッドのオーバーライド(フェイルメッセージ出力系)
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【フェイルメッセージ出力(詳細メッセージなし)】フェイルメッセージをデバッグステーションへ送信します。
        /// </summary>
        /// <param name="message">[in ]：エラー メッセージ</param>
        //--------------------------------------------------------------------------------
        public override void Fail(string message) => Fail(message, null);   /// 詳細メッセージ = null でフェイルメッセージ出力処理を行う


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【フェイルメッセージ出力(詳細メッセージあり)】フェイルメッセージをデバッグステーションへ送信します。
        /// </summary>
        /// <param name="message">      [in ]：エラー メッセージ</param>
        /// <param name="detailMessage">[in ]：詳細エラー メッセージ</param>
        /// <remarks>
        /// 参考：<see cref="TraceListener.Fail(string, string)"/><br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void Fail(string message, string detailMessage)
        {
            //------------------------------------------------------------
            /// フェイルメッセージをデバッグステーションへ送信する
            //------------------------------------------------------------
            M_FlushBuffer();                                            //// 未完メッセージバッファフラッシュ処理を行う(種類が異なるので連結はしない)

            var debugData = DebugData.CreateForFailInfo(
                IndentLevel, message, detailMessage);                   //// フェイル情報用にデバッグデータを生成する
            M_Send(debugData);                                          //// デバッグデータ送信処理を行う
        }


        //====================================================================================================
        // TraceListener メソッドのオーバーライド(トレースイベント出力系)
        //====================================================================================================

        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【トレースイベント出力(メッセージ文字列)】
        /// トレースイベントをデバッグステーションへ送信します。
        /// </summary>
        /// <param name="eventCache">[in ]：トレース イベント データ</param>
        /// <param name="source">    [in ]：イベントソース</param>
        /// <param name="eventType"> [in ]：イベントの種類</param>
        /// <param name="id">        [in ]：イベント識別子</param>
        /// <param name="message">   [in ]：メッセージ文字列</param>
        /// <remarks>
        /// 参考<br></br>
        /// ・<see cref="TraceListener.TraceEvent(TraceEventCache, string, TraceEventType, int, string)"/><br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            //------------------------------------------------------------
            /// トレースイベントをデバッグステーションへ送信する
            //------------------------------------------------------------
            M_FlushBuffer();                                            //// 未完メッセージバッファフラッシュ処理を行う(種類が異なるので連結はしない)

            var debugData = DebugData.CreateForTraceInfo(IndentLevel,
                eventCache, source, eventType, id, message);            //// トレース情報用にデバッグデータを生成する
            M_Send(debugData);                                          //// デバッグデータ送信処理を行う
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【トレースイベント出力(メッセージなし)】
        /// </summary>
        /// <param name="eventCache">[in ]：トレース イベント データ</param>
        /// <param name="source">    [in ]：イベントソース</param>
        /// <param name="eventType"> [in ]：イベントの種類</param>
        /// <param name="id">        [in ]：イベント識別子</param>
        //--------------------------------------------------------------------------------
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
        {
            //------------------------------------------------------------
            /// メッセージ文字列 = null でトレースイベント書き込み処理を行う
            //------------------------------------------------------------
            TraceEvent(eventCache, source, eventType, id, "");
        }


        //--------------------------------------------------------------------------------
        /// <summary>
        /// 【トレースイベント出力(書式指定)】
        /// トレースイベントをデバッグステーションへ送信します。
        /// </summary>
        /// <param name="eventCache">[in ]：トレース イベント データ</param>
        /// <param name="source">    [in ]：イベントソース</param>
        /// <param name="eventType"> [in ]：イベントの種類</param>
        /// <param name="id">        [in ]：イベント識別子</param>
        /// <param name="format">    [in ]：書式指定文字列 参考：<see cref="string.Format(string, object[])"/></param>
        /// <param name="args">      [in ]：書式設定対象オブジェクト配列</param>
        /// <remarks>
        /// 参考<br></br>
        /// ・<see cref="TraceListener.TraceEvent(TraceEventCache, string, TraceEventType, int, string, object[])"/><br></br>
        /// </remarks>
        //--------------------------------------------------------------------------------
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            //------------------------------------------------------------
            /// トレースイベントをデバッグステーションへ送信する
            //------------------------------------------------------------
            var message = string.Format(format, args);                  //// 書式指定文字列と書式設定対象オブジェクト配列からメッセージ文字列を作成する
            TraceEvent(eventCache, source, eventType, id, message);     //// メッセージ文字列指定でトレースイベント出力処理を行う
        }


        //====================================================================================================
        // 保留：TraceListener メソッドのオーバーライド(トレースデータ出力系)
        //====================================================================================================


        //[-] 保留：XMLシリアル化に対応しているオブジェクトは、文字列形式に変換せずにオブジェクト形式のままで送信し、
        //        ：デバッグステーション側で利用できるようにしたい。
        //        ：-> TraceData および オブジェクトを指定する形式の Write, WriteLine

        // ＜未実装のオーバーライド＞
        // ・オブジェクト形式のままでの送信は保留
        //   public override void Write(object o) { }
        //   public override void Write(object o, string category) { }
        //   public override void WriteLine(object o) { }
        //   public override void WriteLine(object o, string category) { }
        //   public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data) { }
        //   public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data) { }
        //
        // ・用途がよくわからない
        //   public override void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId) { }


    }
}
